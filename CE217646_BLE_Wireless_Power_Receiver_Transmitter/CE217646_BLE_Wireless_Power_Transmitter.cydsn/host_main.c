/*******************************************************************************
* File Name: host_main.c
*
* Version: 1.0
*
* Description:
*  This project demonstrates Wireless Power Transfer profile in Power 
*  Transmitter Unit (PTU) Client role.
*
* Related Document:
*  A4WP Wireless Power Transfer System Baseline System Specification (BSS)
*   V1.2.1
*
* Hardware Dependency:
*  CY8CKIT-062 PSoC6 BLE Pioneer Kit
* 
******************************************************************************
* Copyright (2018), Cypress Semiconductor Corporation.
******************************************************************************
* This software is owned by Cypress Semiconductor Corporation (Cypress) and is
* protected by and subject to worldwide patent protection (United States and
* foreign), United States copyright laws and international treaty provisions.
* Cypress hereby grants to licensee a personal, non-exclusive, non-transferable
* license to copy, use, modify, create derivative works of, and compile the
* Cypress Source Code and derivative works for the sole purpose of creating
* custom software in support of licensee product to be used only in conjunction
* with a Cypress integrated circuit as specified in the applicable agreement.
* Any reproduction, modification, translation, compilation, or representation of
* this software except as specified above is prohibited without the express
* written permission of Cypress.
*
* Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH
* REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
* Cypress reserves the right to make changes without further notice to the
* materials described herein. Cypress does not assume any liability arising out
* of the application or use of any product or circuit described herein. Cypress
* does not authorize its products for use as critical components in life-support
* systems where a malfunction or failure may reasonably be expected to result in
* significant injury to the user. The inclusion of Cypress' product in a life-
* support systems application implies that the manufacturer assumes all risk of
* such use and in doing so indemnifies Cypress against all charges. Use may be
* limited by and subject to the applicable Cypress software license agreement.
*****************************************************************************/


#include "common.h"
#include "user_interface.h"

/* Global Variables */
app_stc_connection_info_t       appConnInfo;
app_stc_scan_device_list_t      appScanDevInfo;

static volatile uint32_t        mainTimer  = 1u;
static cy_stc_ble_timer_info_t  timerParam = { .timeout = TIMER_TIMEOUT };
static uint8_t                  deviceToConnect = 0u;

/* Private Function Prototypes */
static uint8_t IsPeerBdAddrConnected(uint8_t *bdAddr);
static void DisplayDevicesStatus(void);


/*******************************************************************************
* Function Name: IsPeerBdAddrConnected
********************************************************************************
*
* Summary:
*   Checks if bdAddr is connected.
*
* Parameters:
*   \param *bdAddr: The pointer to the peer address array.
*
* Return:
*   isConnectedFlag: 1u - connected, 0u - not connected.
*
*******************************************************************************/
static uint8_t IsPeerBdAddrConnected(uint8_t *bdAddr)
{ 
    uint32_t isConnectedFlag = 0u;
    uint32_t i;
    
    /* Client/Server  */
    for(i = 0u; i < CY_BLE_CONFIG_CONN_COUNT; i++)
    {
        if(Cy_BLE_GetConnectionState(cy_ble_connHandle[i]) >= CY_BLE_CONN_STATE_CONNECTED)
        {
            /* Get BdAddress from bdHandle of the connected device */
            cy_stc_ble_gap_peer_addr_info_t param = {.bdHandle = cy_ble_connHandle[i].bdHandle};
            Cy_BLE_GAP_GetPeerBdAddr(&param);
            
            if( AddressCompare(&param.bdAddr.bdAddr, bdAddr) == true)
            {
                isConnectedFlag = 1u;
                break;
            } 
        }
    }
    return (isConnectedFlag);
}


/*******************************************************************************
* Function Name: AppCallBack()
********************************************************************************
*
* Summary:
*   This is an event callback function to receive events from the BLE Component.
*
* Parameters:
*  event       - the event code
*  *eventParam - the event parameters
*
* Theory:
* The function is responsible for handling the events generated by the stack.
* It first starts scanning once the stack is initialized. 
* Upon scanning timeout this function enters Hibernate mode.
*
*******************************************************************************/
void AppCallBack(uint32_t event, void* eventParam)
{
    cy_en_ble_api_result_t apiResult;
    cy_stc_ble_gattc_grp_attr_data_list_t *locAttrData;
    uint16_t i;
    uint16_t length;
    uint8_t *locHndlUuidList;
    uint8_t type;
    
    switch (event)
    {
        case CY_BLE_EVT_STACK_ON: /* This event received when BLE stack is ON. */
            DBG_PRINTF("CY_BLE_EVT_STACK_ON, StartScanning \r\n");   
            /* Start Limited Discovery */
            apiResult = Cy_BLE_GAPC_StartScan(CY_BLE_SCANNING_FAST, CY_BLE_CENTRAL_CONFIGURATION_0_INDEX);
            if(apiResult != CY_BLE_SUCCESS)
            {
                DBG_PRINTF("StartScan API Error: %xd \r\n", apiResult);
            }
            break;
            
        case CY_BLE_EVT_TIMEOUT: 
            if((((cy_stc_ble_timeout_param_t *)eventParam)->reasonCode == CY_BLE_GENERIC_APP_TO) && 
               (((cy_stc_ble_timeout_param_t *)eventParam)->timerHandle == timerParam.timerHandle))
            {
                /* Update Led State */
                UpdateLedState();
                
                /* Indicate that timer is raised to the main loop */
                mainTimer++;
            }
            else
            {
                DBG_PRINTF("CY_BLE_EVT_TIMEOUT: %x \r\n", ((cy_stc_ble_timeout_param_t *)eventParam)->reasonCode);
            }             
            break;
            
        case CY_BLE_EVT_HARDWARE_ERROR:    /* This event indicates that some internal HW error has occurred */
            DBG_PRINTF("Hardware Error: %x \r\n", *(uint8_t *)eventParam);
            break;
            
        case CY_BLE_EVT_STACK_BUSY_STATUS:
            DBG_PRINTF("CY_BLE_EVT_STACK_BUSY_STATUS: %x\r\n", *(uint8_t *)eventParam);
            break;
            
        case CY_BLE_EVT_SET_TX_PWR_COMPLETE:
            DBG_PRINTF("CY_BLE_EVT_SET_TX_PWR_COMPLETE \r\n");
            break;
            
        case CY_BLE_EVT_LE_SET_EVENT_MASK_COMPLETE:
            DBG_PRINTF("CY_BLE_EVT_LE_SET_EVENT_MASK_COMPLETE \r\n");
            break;
            
        case CY_BLE_EVT_SET_DEVICE_ADDR_COMPLETE:
            DBG_PRINTF("CY_BLE_EVT_SET_DEVICE_ADDR_COMPLETE \r\n");
            break;   
            
        case CY_BLE_EVT_STACK_SHUTDOWN_COMPLETE:
            DBG_PRINTF("CY_BLE_EVT_STACK_SHUTDOWN_COMPLETE \r\n");
            DBG_PRINTF("Hibernate \r\n");
            UART_DEB_WAIT_TX_COMPLETE();
            UpdateLedState();
            /* Hibernate */
            Cy_SysPm_Hibernate();
            break;   
            
        /**********************************************************
        *                       GAP Events
        ***********************************************************/
            
        /* This event provides the remote device lists during discovery process */
        case CY_BLE_EVT_GAPC_SCAN_PROGRESS_RESULT:
        {
            cy_stc_ble_gapc_adv_report_param_t  *advReport = (cy_stc_ble_gapc_adv_report_param_t *)eventParam;
            cy_stc_ble_pru_adv_service_data_t serviceData;

            bool printHeader  = false;
            bool isNewAddress = true;
                            
            if((appScanDevInfo.pauseScanProgress == false) && 
               (advReport->eventType == CY_BLE_GAPC_CONN_UNDIRECTED_ADV))
            {
                /* Filter and add to the connect list only nodes that advertise WPTS in ADV payload */
                if(((WptsScanProcessEventHandler(advReport, &serviceData) != 0u) != 0u) &&
                   (Cy_BLE_GetState() != CY_BLE_STATE_CONNECTING) && (appScanDevInfo.count < CY_BLE_MAX_SCAN_DEVICES) &&
                   (IsPeerBdAddrConnected(advReport->peerBdAddr) == 0u))
                {
                    /* Detected devices are stored in peerAddr[] array. User can review this list 
                     * by pressing 'c' button and selecting a device for connection. 
                     */
                    for(i = 0u; i < CY_BLE_MAX_SCAN_DEVICES; i++)
                    {
                        if(!(memcmp(&appScanDevInfo.address[i].bdAddr, advReport->peerBdAddr, CY_BLE_GAP_BD_ADDR_SIZE)))
                        {
                            isNewAddress = false;
                        }
                    }
                    
                    if(isNewAddress == true)
                    {
                        memcpy(&appScanDevInfo.address[appScanDevInfo.count].bdAddr, advReport->peerBdAddr,
                                                                             CY_BLE_GAP_BD_ADDR_SIZE); 
                        appScanDevInfo.address[appScanDevInfo.count].type = advReport->peerAddrType;
                        appScanDevInfo.peerAdvServData[appScanDevInfo.count] = serviceData;
                        appScanDevInfo.count++;
                        printHeader = true;
                    }
                }
                
                /* Display scanned device ADV data */
                if((printHeader == true) && (isNewAddress == true))
                {
                    DBG_PRINTF("\r\n-------------------------------------------------------------------------\r\n");
                    DBG_PRINTF("uuid: WIRELESS POWER TRANSFER SERVICE - YES, added to the connect list  \r\n");
                } 
                DBG_PRINTF("ADV type: 0x%x address: ", advReport->eventType );
                for(i = CY_BLE_GAP_BD_ADDR_SIZE; i > 0u; i--)
                {
                    DBG_PRINTF("%2.2x", advReport->peerBdAddr[i-1]);
                }
                DBG_PRINTF(", rssi - %d dBm, data - ", advReport->rssi);
                for( i = 0; i < advReport->dataLen; i++)
                {
                    DBG_PRINTF("%2.2x ", advReport->data[i]);
                }
                DBG_PRINTF("\r\n");
                if((printHeader == true) && (isNewAddress == true))
                {            
                    DBG_PRINTF("-------------------------------------------------------------------------\r\n\r\n");
                }  
            }  
        }
        break; 
                    
        case CY_BLE_EVT_GAPC_SCAN_START_STOP:
            DBG_PRINTF("CY_BLE_EVT_GAPC_SCAN_START_STOP\r\n");
            if(Cy_BLE_GetScanState() == CY_BLE_SCAN_STATE_STOPPED)
            {
                DBG_PRINTF("Scan complete! \r\n \r\n");
                
                if(appScanDevInfo.connReq)
                {
                    /* Perform connection to peer device */
                    apiResult = Cy_BLE_GAPC_ConnectDevice(&appScanDevInfo.address[appScanDevInfo.connReq - 1u], 
                                                           CY_BLE_CENTRAL_CONFIGURATION_0_INDEX);
                    if(apiResult != CY_BLE_SUCCESS)
                    {
                        DBG_PRINTF("ConnectDevice API Error: 0x%x ", apiResult);
                    }
                    else
                    {
                        DBG_PRINTF("Connecting to the device ");
                        /* Print the devices Addr of the detected Client */
                        DBG_PRINTF("%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x \r\n",
                                                    appScanDevInfo.address[appScanDevInfo.connReq - 1u].bdAddr[5u], 
                                                    appScanDevInfo.address[appScanDevInfo.connReq - 1u].bdAddr[4u],
                                                    appScanDevInfo.address[appScanDevInfo.connReq - 1u].bdAddr[3u], 
                                                    appScanDevInfo.address[appScanDevInfo.connReq - 1u].bdAddr[2u],
                                                    appScanDevInfo.address[appScanDevInfo.connReq - 1u].bdAddr[1u], 
                                                    appScanDevInfo.address[appScanDevInfo.connReq - 1u].bdAddr[0u]); 
                    } 
                    deviceToConnect = appScanDevInfo.connReq - 1u; 
                    appScanDevInfo.connReq = 0u;
                }
                else
                {
                    if(Cy_BLE_GetNumOfActiveConn() == 0u)
                    {
                        /* Fast scanning period complete,
                         * go to low power mode (Hibernate mode) and wait for an external
                         * user event to wake up the device again */
                        Cy_BLE_Stop();
                    }
                    else
                    {
                        /* Start Limited Discovery */
                        apiResult = Cy_BLE_GAPC_StartScan(CY_BLE_SCANNING_FAST, CY_BLE_CENTRAL_CONFIGURATION_0_INDEX);
                        if(apiResult != CY_BLE_SUCCESS)
                        {
                            DBG_PRINTF("StartScan API Error: %xd \r\n", apiResult);
                        }
                    }
                }
            }
            else
            {
                DBG_PRINTF("GAPC_START_SCANNING\r\n");
            }
            break;
                     
       case CY_BLE_EVT_GAP_AUTH_REQ:
            /* This event is received by Peripheral and Central devices. When it is received by a peripheral, 
             * that peripheral must Call Cy_BLE_GAPP_AuthReqReply() to reply to the authentication request
             * from Central. */
            DBG_PRINTF("CY_BLE_EVT_GAP_AUTH_REQ: bdHandle=%x, security=%x, bonding=%x, ekeySize=%x, err=%x \r\n", 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).bdHandle, (*(cy_stc_ble_gap_auth_info_t *)eventParam).security, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).bonding, (*(cy_stc_ble_gap_auth_info_t *)eventParam).ekeySize, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).authErr);
            
            if(cy_ble_configPtr->authInfo[CY_BLE_SECURITY_CONFIGURATION_0_INDEX].security == 
                (CY_BLE_GAP_SEC_MODE_1 | CY_BLE_GAP_SEC_LEVEL_1))
            {
                cy_ble_configPtr->authInfo[CY_BLE_SECURITY_CONFIGURATION_0_INDEX].authErr = 
                    CY_BLE_GAP_AUTH_ERROR_PAIRING_NOT_SUPPORTED;
            }    
            
            cy_ble_configPtr->authInfo[CY_BLE_SECURITY_CONFIGURATION_0_INDEX].bdHandle = 
                ((cy_stc_ble_gap_auth_info_t *)eventParam)->bdHandle;

            /* Pass security information for authentication in reply to an authentication request 
             * from the master device */
            apiResult = Cy_BLE_GAPP_AuthReqReply(&cy_ble_configPtr->authInfo[CY_BLE_SECURITY_CONFIGURATION_0_INDEX]);            
            if(apiResult != CY_BLE_SUCCESS)
            {
                Cy_BLE_GAP_RemoveOldestDeviceFromBondedList();
                apiResult = Cy_BLE_GAPP_AuthReqReply(&cy_ble_configPtr->authInfo[CY_BLE_SECURITY_CONFIGURATION_0_INDEX]);            
                if(apiResult != CY_BLE_SUCCESS)
                {
                    DBG_PRINTF("Cy_BLE_GAPP_AuthReqReply API Error: 0x%x \r\n", apiResult);
                }
            }
            break;
            
        case CY_BLE_EVT_GAP_KEYINFO_EXCHNGE_CMPLT:
            DBG_PRINTF("CY_BLE_EVT_GAP_KEYINFO_EXCHNGE_CMPLT \r\n");
            break;
            
        case CY_BLE_EVT_GAP_SMP_NEGOTIATED_AUTH_INFO:
            DBG_PRINTF("CY_BLE_EVT_GAP_SMP_NEGOTIATED_AUTH_INFO:" 
                       " bdHandle=%x, security=%x, bonding=%x, ekeySize=%x, err=%x \r\n", 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).bdHandle, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).security, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).bonding, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).ekeySize, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).authErr);
            break;
        
        case CY_BLE_EVT_GAP_AUTH_COMPLETE:
            DBG_PRINTF("CY_BLE_EVT_GAP_AUTH_COMPLETE: bdHandle=%x, security=%x, bonding=%x, ekeySize=%x, err=%x \r\n", 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).bdHandle, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).security, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).bonding, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).ekeySize, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).authErr);
            break;
         
        case CY_BLE_EVT_GAP_AUTH_FAILED:
            DBG_PRINTF("CY_BLE_EVT_GAP_AUTH_FAILED: bdHandle=%x, authErr=%x\r\n", 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).bdHandle, 
                (*(cy_stc_ble_gap_auth_info_t *)eventParam).authErr);
            break;
            
        case CY_BLE_EVT_GAP_ENCRYPT_CHANGE:
            DBG_PRINTF("CY_BLE_EVT_GAP_ENCRYPT_CHANGE: %x \r\n", *(uint8_t *)eventParam);
            break;
            
        case CY_BLE_EVT_GAP_DEVICE_CONNECTED:
            DBG_PRINTF("CY_BLE_EVT_GAP_DEVICE_CONNECTED: connIntv = %d ms \r\n",          /* in milliseconds / 1.25ms */
                        ((cy_stc_ble_gap_connected_param_t *)eventParam)->connIntv * CY_BLE_CONN_INTRV_TO_MS);
            break;
            
        case CY_BLE_EVT_GAP_DEVICE_DISCONNECTED:
            DBG_PRINTF("CY_BLE_EVT_GAP_DEVICE_DISCONNECTED: bdHandle=%x, reason=%x, status=%x\r\n",
                (*(cy_stc_ble_gap_disconnect_param_t *)eventParam).bdHandle, 
                (*(cy_stc_ble_gap_disconnect_param_t *)eventParam).reason, 
                (*(cy_stc_ble_gap_disconnect_param_t *)eventParam).status);
            break;
            
        case CY_BLE_EVT_L2CAP_CONN_PARAM_UPDATE_RSP:
            DBG_PRINTF("CY_BLE_EVT_L2CAP_CONN_PARAM_UPDATE_RSP, bdHandle=%x, result = %d\r\n", 
                (*(cy_stc_ble_l2cap_conn_update_rsp_param_t *)eventParam).bdHandle,
                (*(cy_stc_ble_l2cap_conn_update_rsp_param_t *)eventParam).result);
            break; 
            
        case CY_BLE_EVT_GAP_CONNECTION_UPDATE_COMPLETE:
            DBG_PRINTF("CY_BLE_EVT_GAP_CONNECTION_UPDATE_COMPLETE: connIntv = %d ms \r\n", /* in milliseconds / 1.25ms */
                        ((cy_stc_ble_gap_conn_param_updated_in_controller_t *)eventParam)->connIntv * CY_BLE_CONN_INTRV_TO_MS);
            break;

            
        /**********************************************************
        *                       GATT Events
        ***********************************************************/
        case CY_BLE_EVT_GATT_CONNECT_IND:
        {
            cy_stc_ble_conn_handle_t  connHandle = *(cy_stc_ble_conn_handle_t *)eventParam;
            
            DBG_PRINTF("CY_BLE_EVT_GATT_CONNECT_IND: %x, %x \r\n", 
                (*(cy_stc_ble_conn_handle_t *)eventParam).attId, 
                (*(cy_stc_ble_conn_handle_t *)eventParam).bdHandle);

            appConnInfo.central[connHandle.attId].pruState = PEER_DEVICE_STATE_ADDED;
            appConnInfo.central[connHandle.attId].pruCharging = false;
            appConnInfo.central[connHandle.attId].requestResponce = false;
            
            DBG_PRINTF("appScanDevInfo.peerAdvServData[deviceToConnect].wptsServiceHandle %x, \r\n",
                        appScanDevInfo.peerAdvServData[deviceToConnect].wptsServiceHandle);
            if(appScanDevInfo.peerAdvServData[deviceToConnect].wptsServiceHandle != 0u)
            {
                /* Use quick discovery method based on WPT service handle received in the advertising packet */
                apiResult = Cy_BLE_WPTSC_Discovery(appScanDevInfo.peerAdvServData[deviceToConnect].wptsServiceHandle, connHandle);
                if(apiResult != CY_BLE_SUCCESS)
                {
                    DBG_PRINTF("Cy_BLE_WPTSC_Discovery API Error: %x \r\n", apiResult);
                }
                
            #if(DEBUG_UART_EXTENDED)  
                DBG_PRINTF("WPTS %x: ",  
                    cy_ble_wptsc[Cy_BLE_GetDiscoveryIdx(connHandle)].serviceHandle);
                for(i = 0u; i < CY_BLE_WPTS_CHAR_COUNT; i++)
                {
                    DBG_PRINTF("Char %x=%x, CCCD=%x ", i, 
                        Cy_BLE_WPTSC_GetCharacteristicValueHandle(connHandle, i),
                        Cy_BLE_WPTSC_GetCharacteristicDescriptorHandle(connHandle, i, 0u));
                }
                DBG_PRINTF("\r\n");
            #endif /* DEBUG_UART_EXTENDED */
                /* Initiate to read PRU Static Parameter characteristic value */
                apiResult = Cy_BLE_WPTSC_GetCharacteristicValue(connHandle, CY_BLE_WPTS_PRU_STATIC_PAR);
                DBG_PRINTF("Get PRU Static Parameter char value, attId: %x, apiResult: %x \r\n", connHandle.attId, apiResult);
                if(apiResult == CY_BLE_SUCCESS)
                {
                    appConnInfo.central[connHandle.attId].requestResponce = true;
                }
            }
            else
            {
                /* When the service handle is unknown, use the standard discovery procedure */
                /* Disable sequential read of PRU Dynamic Parameter characteristic before discovery procedure */
                appConnInfo.central[connHandle.attId].readingDynChar = 0u;
                apiResult = Cy_BLE_GATTC_StartDiscovery(connHandle);
                DBG_PRINTF("StartDiscovery \r\n");
                if(apiResult != CY_BLE_SUCCESS)
                {
                    DBG_PRINTF("StartDiscovery API Error: %x \r\n", apiResult);
                }
            }
        }
            break;
            
        case CY_BLE_EVT_GATT_DISCONNECT_IND:
            DBG_PRINTF("CY_BLE_EVT_GATT_DISCONNECT_IND: %x, %x \r\n", 
                (*(cy_stc_ble_conn_handle_t *)eventParam).attId, 
                (*(cy_stc_ble_conn_handle_t *)eventParam).bdHandle);
            
            apiResult = Cy_BLE_GAPC_StartScan(CY_BLE_SCANNING_FAST, CY_BLE_CENTRAL_CONFIGURATION_0_INDEX);
            if(apiResult != CY_BLE_SUCCESS)
            {
                DBG_PRINTF("StartScan API Error: %xd \r\n", apiResult);
            }
            
            break;
        
        case CY_BLE_EVT_GATTC_ERROR_RSP:
            DBG_PRINTF("GATT_ERROR_RSP: opcode: %x,  handle: %x,  errorcode: %x \r\n",
                ((cy_stc_ble_gatt_err_param_t *)eventParam)->errInfo.opCode,
                ((cy_stc_ble_gatt_err_param_t *)eventParam)->errInfo.attrHandle,
                ((cy_stc_ble_gatt_err_param_t *)eventParam)->errInfo.errorCode);
            break;
        
        case CY_BLE_EVT_GATTC_HANDLE_VALUE_NTF:
            DBG_PRINTF("CY_BLE_EVT_GATT_HANDLE_VALUE_NTF: handle: %x, Value:", 
                ((cy_stc_ble_gattc_handle_value_ind_param_t *)eventParam)->handleValPair.attrHandle );
            ShowValue(&((cy_stc_ble_gattc_handle_value_ind_param_t *)eventParam)->handleValPair.value);
            break;  
            
        case CY_BLE_EVT_GATTC_HANDLE_VALUE_IND:
            DBG_PRINTF("CY_BLE_EVT_GATTC_HANDLE_VALUE_IND: handle: %x, Value:", 
                ((cy_stc_ble_gattc_handle_value_ind_param_t *)eventParam)->handleValPair.attrHandle );
            ShowValue(&((cy_stc_ble_gattc_handle_value_ind_param_t *)eventParam)->handleValPair.value);
            break;
            
        case CY_BLE_EVT_GATTC_INDICATION:
            DBG_PRINTF("CY_BLE_EVT_GATTC_INDICATION: handle: %x, Value:", 
                ((cy_stc_ble_gattc_handle_value_ind_param_t *)eventParam)->handleValPair.attrHandle );
            ShowValue(&((cy_stc_ble_gattc_handle_value_ind_param_t *)eventParam)->handleValPair.value);
            break;
            
        case CY_BLE_EVT_GATTC_READ_RSP:
            DBG_PRINTF("CY_BLE_EVT_GATT_READ_RSP: ");
            ShowValue(&((cy_stc_ble_gattc_read_rsp_param_t *)eventParam)->value);
            break;   
            
        case CY_BLE_EVT_GATTC_READ_BLOB_RSP:
            DBG_PRINTF("CY_BLE_EVT_GATTC_READ_BLOB_RSP: ");
            ShowValue(&((cy_stc_ble_gattc_read_rsp_param_t *)eventParam)->value);
            break;
            
        case CY_BLE_EVT_GATTC_WRITE_RSP:
            DBG_PRINTF("CY_BLE_EVT_GATT_WRITE_RSP \r\n");
            break;     
            
        case CY_BLE_EVT_GATTS_XCNHG_MTU_REQ:
            DBG_PRINTF("CY_BLE_EVT_GATTS_XCNHG_MTU_REQ \r\n");
            break;
            
        case CY_BLE_EVT_GATTC_XCHNG_MTU_RSP:
            DBG_PRINTF("CY_BLE_EVT_GATTC_XCHNG_MTU_RSP: \r\n");
            DBG_PRINTF("MTU is set to %d Bytes\r\n", (*(cy_stc_ble_gatt_xchg_mtu_param_t *)eventParam).mtu);
            break;
            
        case CY_BLE_EVT_GATTC_READ_BY_GROUP_TYPE_RSP: /* Response to CY_BLE_DiscoverAllPrimServices() */
            DBG_PRINTF("CY_BLE_EVT_GATT_READ_BY_GROUP_TYPE_RSP: ");
            locAttrData = &(*(cy_stc_ble_gattc_read_by_grp_rsp_param_t *)eventParam).attrData;
            for(i = 0u; i < locAttrData -> attrLen; i ++)
            { 
                DBG_PRINTF("%2.2x ",*(uint8_t *)(locAttrData->attrValue + i));
            }
                DBG_PRINTF("\r\n");
            break;
                
        case CY_BLE_EVT_GATTC_READ_BY_TYPE_RSP:      /* Response to CY_BLE_DiscoverAllCharacteristicsOfService() */
            DBG_PRINTF("CY_BLE_EVT_GATT_READ_BY_TYPE_RSP: ");
            locAttrData = &(*(cy_stc_ble_gattc_read_by_type_rsp_param_t *)eventParam).attrData;
            for(i = 0u; i < locAttrData -> attrLen; i ++)
            { 
                DBG_PRINTF("%2.2x ",*(uint8_t *)(locAttrData->attrValue + i));
            }
            DBG_PRINTF("\r\n");
            break;
            
        case CY_BLE_EVT_GATTC_FIND_INFO_RSP:
            DBG_PRINTF("CY_BLE_EVT_GATT_FIND_INFO_RSP: ");
            type = (*(cy_stc_ble_gattc_find_info_rsp_param_t *)eventParam).uuidFormat;
            locHndlUuidList = (*(cy_stc_ble_gattc_find_info_rsp_param_t *)eventParam).handleValueList.list;
            (void)locHndlUuidList;
            if(type == CY_BLE_GATT_16_BIT_UUID_FORMAT)
            {
                length = CY_BLE_DB_ATTR_HANDLE_LEN + CY_BLE_GATT_16_BIT_UUID_SIZE;
            }
            else
            {
                length = CY_BLE_DB_ATTR_HANDLE_LEN + CY_BLE_GATT_128_BIT_UUID_SIZE;
            }
            for(i = 0u; i < (*(cy_stc_ble_gattc_find_info_rsp_param_t *)eventParam).handleValueList.byteCount; i += length)
            {
                if(type == CY_BLE_GATT_16_BIT_UUID_FORMAT)
                {
                    DBG_PRINTF("%2.2x %2.2x,",Cy_BLE_Get16ByPtr(locHndlUuidList + i),
                                              Cy_BLE_Get16ByPtr(locHndlUuidList + i + CY_BLE_DB_ATTR_HANDLE_LEN));
                }
                else
                {
                    DBG_PRINTF("UUID128");
                }
            }
            DBG_PRINTF("\r\n");
            break;
            
        case CY_BLE_EVT_GATTC_FIND_BY_TYPE_VALUE_RSP:
            DBG_PRINTF("CY_BLE_EVT_GATT_FIND_BY_TYPE_VALUE_RSP \r\n");
            break;
                
        /**********************************************************
        *                       Discovery Events 
        ***********************************************************/
        case CY_BLE_EVT_GATTC_DISCOVERY_COMPLETE:
        {
            cy_stc_ble_conn_handle_t  connHandle = *(cy_stc_ble_conn_handle_t *)eventParam;
            uint8_t discIdx = Cy_BLE_GetDiscoveryIdx(connHandle);    

            DBG_PRINTF("CY_BLE_EVT_GATTC_DISCOVERY_COMPLETE: attId=%x, bdHandle=%x \r\n", 
                            (*(cy_stc_ble_conn_handle_t *)eventParam).attId, 
                            (*(cy_stc_ble_conn_handle_t *)eventParam).bdHandle);   
            DBG_PRINTF("GATT %x-%x Char: %x, cccd: %x, \r\n", 
                cy_ble_serverInfo[discIdx][CY_BLE_SRVI_GATT].range.startHandle,
                cy_ble_serverInfo[discIdx][CY_BLE_SRVI_GATT].range.endHandle,
                cy_ble_discovery[discIdx].gattc.serviceChanged.valueHandle,
                cy_ble_discovery[discIdx].gattc.cccdHandle);
            DBG_PRINTF("\r\nWPTS %x-%x: ",  cy_ble_serverInfo[discIdx][CY_BLE_SRVI_WPTS].range.startHandle,
                                            cy_ble_serverInfo[discIdx][CY_BLE_SRVI_WPTS].range.endHandle);
            for(i = 0u; i < CY_BLE_WPTS_CHAR_COUNT; i++)
            {
                DBG_PRINTF("Char %x=%x, CCCD=%x ", i, Cy_BLE_WPTSC_GetCharacteristicValueHandle(connHandle, i),
                    Cy_BLE_WPTSC_GetCharacteristicDescriptorHandle(connHandle, i, 0u));
            }
            DBG_PRINTF("\r\n");
            DBG_PRINTF("\r\n");
            
            /* Start configuration procedure */
            /* Initiate to read PRU Static Parameter characteristic value */
            apiResult = Cy_BLE_WPTSC_GetCharacteristicValue(connHandle, CY_BLE_WPTS_PRU_STATIC_PAR);
            DBG_PRINTF("Get PRU Static Parameter char value, attId: %x, apiResult: %x \r\n", connHandle.attId, apiResult);
            if(apiResult == CY_BLE_SUCCESS)
            {
                appConnInfo.central[connHandle.attId].requestResponce = true;
            }
        }
        break;

        /**********************************************************
        *                       Other Events
        ***********************************************************/
        case CY_BLE_EVT_PENDING_FLASH_WRITE:
            /* Inform application that flash write is pending. Stack internal data 
            * structures are modified and require to be stored in Flash using 
            * Cy_BLE_StoreBondingData() */
            DBG_PRINTF("CY_BLE_EVT_PENDING_FLASH_WRITE\r\n");
            break;
        default:
            DBG_PRINTF("OTHER event: %lx \r\n", event);
            break;
    }
}
        

/*******************************************************************************
* Function Name: DisplayDevicesStatus()
********************************************************************************
*
* Summary:
*  Display the number of configured devices and their status
*
*******************************************************************************/
static void DisplayDevicesStatus(void)
{
    uint16_t i;    
    static uint16_t timeout = 0u;    
    
    if(++timeout >= STATUS_TIMEOUT)
    {
        timeout = 0u;
        if(Cy_BLE_GetNumOfActiveConn() != 0u) 
        {  
            DBG_PRINTF("N of Devices: %d;", Cy_BLE_GetNumOfActiveConn());
               
            for(i = 0u; i < CY_BLE_CONN_COUNT; i++)
            {   
                if(Cy_BLE_GetConnectionState(cy_ble_connHandle[i]) == CY_BLE_CONN_STATE_CLIENT_DISCOVERED)            
                {
                    /* Display device list */         
                    DBG_PRINTF(" #%d Charge=%d, Vrect: %d mV;", i, 
                        appConnInfo.central[i].pruCharging, appConnInfo.central[i].pruDynamicPar.vRect);
                }
            }
            DBG_PRINTF("\r\n");
        }
    }
}


/*******************************************************************************
* Function Name: HostMain()
********************************************************************************
*
* Summary:
*  The main function of the project. The function performs the following 
*  actions:
*   1. Performs initialization of the BLE and ISR components. It also registers
*      all the service's callback functions for the BLE component.
*   2. Invokes handling of the BLE related events.
*   3. Simulates the Wireless Power Transfer device operation.
*   4. Performs handling of the low-power modes for the device.
*
*******************************************************************************/
int HostMain()
{
    cy_en_ble_api_result_t apiResult;
    char8 command = 0u;
    
    /* Initialization the user interface: LEDs, SW2, etc.  */
    InitUserInterface();

    UART_DEB_Start();               /* Start communication component */
    DBG_PRINTF("BLE Wireless Power Transmitter Code Example \r\n");
    
    /* Start BLE component and register generic event handler */
    apiResult = Cy_BLE_Start(AppCallBack);
    if(apiResult != CY_BLE_SUCCESS)
    {
        DBG_PRINTF("Cy_BLE_Start API Error: 0x%x \r\n", apiResult);
    }

    /* Print stack version */
    PrintStackVersion();
    
    /* Register service specific callback functions */
    WptsInit();
    
    /***************************************************************************
    * Main polling loop
    ***************************************************************************/
    while(1u)
    {
        /* Process all the generated events */
        Cy_BLE_ProcessEvents();

        /* Restart 1 second timer */
        if(mainTimer != 0u)
        {
            mainTimer = 0u;
            Cy_BLE_StartTimer(&timerParam);
            
            if(Cy_BLE_GetNumOfActiveConn() != 0u) 
            {
                uint32_t i;
                
                /* Send Read request for PRU Dynamic Parameter characteristic */
                for(i = 0u; i < CY_BLE_CONN_COUNT; i++)
                {  
                    if((Cy_BLE_GetConnectionState(cy_ble_connHandle[i]) == CY_BLE_CONN_STATE_CLIENT_DISCOVERED) &&
                       (appConnInfo.central[i].readingDynChar != 0u) && (appConnInfo.central[i].requestResponce == false))
                    {                    
                        apiResult = Cy_BLE_WPTSC_GetCharacteristicValue(cy_ble_connHandle[i], CY_BLE_WPTS_PRU_DYNAMIC_PAR);
                        appConnInfo.central[i].requestResponce = (apiResult == CY_BLE_SUCCESS) ? true : false;
    
                    #if(DEBUG_UART_EXTENDED)  
                        DBG_PRINTF("Device %lu-->Get PRU Dynamic Parameter char value, apiResult: %x \r\n", i, apiResult);
                    #endif /* (DEBUG_UART_EXTENDED) */
            
                    }
                }
            }
            
            /* Periodically display devices status */        
            DisplayDevicesStatus();        
        }
        
        /* Process command from debug terminal */
        if((command = UART_DEB_GET_CHAR()) != UART_DEB_NO_DATA) 
        {
            ProcessUartCommands(command); 
        }
    }
}

/* [] END OF FILE */
